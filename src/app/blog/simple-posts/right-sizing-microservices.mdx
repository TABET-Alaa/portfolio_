---
title: "Right-Sizing Microservices: Finding the Balance in Migration"
publishedAt: "2025-10-29"
summary: "Migrating from a monolith to microservices is not just about containers and Kubernetes â€” itâ€™s about finding the right service boundaries. Learn how right-sizing and domain-driven design help avoid the traps of both oversized and over-fragmented services, with a real-world example from a financial system."


  
---

Migrating from a monolith to microservices in an agile team is **never easy**.  
It sounds exciting in theory â€” independent deployments, faster delivery, scalable systems â€” but once youâ€™re in the middle of it, the real questions become much more practical:

ğŸ‘‰ *What do we migrate first?*  
ğŸ‘‰ *How do we know where one service should begin and another should end?*

This is where **right-sizing and identifying service boundaries** make all the difference.

---

### ğŸš§ The Common Trap

Letâ€™s picture a real-world situation in a **banking or fintech system**.

Youâ€™re maintaining a large **core banking monolith** that handles everything â€” customer onboarding, accounts, transactions, cards, payments, and even compliance.  

A simple update like adding a â€œdaily transaction limitâ€ feature requires coordination between five teams, full regression testing, and a night-time deployment window. Frustration grows, so the decision is made: *letâ€™s move to microservices.*

The first instinct? Cut the monolith into pieces.  
You isolate the â€œPaymentsâ€ module, wrap it in a Docker container, and call it a microservice. ğŸ‰  

But internally, the `PaymentService` still directly accesses customer data, account balances, and even risk checks through shared database tables. Youâ€™ve only **moved the monolith into a container** â€” all the same couplings remain.  

Now, the â€œCustomerâ€ team changes a column in the database, and suddenly â€œPaymentsâ€ stops working. Deployment independence? Gone. Scalability? Limited.  

On the other extreme, some teams swing the other way â€” slicing the system too thin.  
They build a microservice for **every single function**:  
`TransactionValidatorService`, `LimitCheckerService`, `FeeCalculatorService`, `NotificationSenderService`...  

Before long, a single payment flow involves 10 different services talking to each other in sequence.  
When a transaction fails, tracing it across logs feels like detective work â€” and the operational overhead becomes enormous.  

Both extremes are traps.  

---

### âš–ï¸ The Balance: Right-Sizing

Right-sizing means **finding the sweet spot** â€” designing services that are big enough to represent a **business capability**, but small enough to evolve, deploy, and scale independently.

Here are two proven methods teams use to get it right:

#### 1. **Domain-Driven Sizing**

Align your services with **business domains**, not technical layers.  
In a financial system, natural domain boundaries often look like this:

- **Accounts Service** â†’ manages account creation, balances, and limits  
- **Payments Service** â†’ handles transfers, bill payments, and settlements  
- **Risk Service** â†’ manages fraud detection and transaction scoring  
- **Notifications Service** â†’ handles alerts, emails, and SMS updates  

Each of these services represents a **bounded context** â€” a complete, self-contained domain that evolves on its own.  

This is how many modern fintechs like **Revolut** or **N26** structure their systems.  
Their â€œPaymentsâ€ team owns the full lifecycle of a transaction â€” from initiation to settlement â€” without depending on dozens of other services.

#### 2. **Event-Storming Sizing**

When business logic isnâ€™t crystal clear, **event storming** is your best friend.  
Bring together product owners, developers, and operations.  
Map the **real-world events** that happen in the system:  

> â€œAccountOpenedâ€ â†’ â€œFundsTransferredâ€ â†’ â€œTransactionApprovedâ€ â†’ â€œNotificationSentâ€

Youâ€™ll quickly see how these events cluster naturally.  
For example, â€œFundsTransferredâ€ and â€œTransactionApprovedâ€ clearly belong together in the Payments domain, while â€œNotificationSentâ€ is separate.  

This method exposes hidden dependencies and helps you define **natural service boundaries** around actual business flows â€” not arbitrary technical layers.

---

### ğŸ’¡ A Quick Case Study

A digital bank tried to migrate its monolith core into microservices.  
Initially, they split services by **technical concerns**: APIs, logic, database.  
Each microservice still touched the same massive Oracle database. The result? Endless integration bugs and zero autonomy.  

They rebooted the approach, this time using **business-driven boundaries**.  
They defined four key microservices:  
- Customer Management  
- Payments  
- Risk  
- Notifications  

Each service owned its own schema and data.  
The Risk service, for example, used Kafka events like `TransactionInitiated` to run real-time fraud scoring without directly touching the Payments database.  

Within months, their deployment frequency jumped from **one release per month** to **multiple per week**, with fewer cross-team dependencies.  

Thatâ€™s what right-sizing looks like in practice.  

---

### ğŸš€ Why It Matters

Without right-sizing, migrating to microservices becomes a trap:  
either youâ€™re **carrying your monolith problem into containers**, or youâ€™re **drowning in a sea of tiny services**.  

With clear service boundaries, you unlock the *real* benefits of microservices:
- Independent deployments  
- Faster iteration cycles  
- Business-aligned teams  
- Scalability and resilience  

Because at its core, microservices are **not a technology choice** â€” theyâ€™re an **organizational and architectural discipline**.

---

ğŸ‘‰ **This is the heart of the challenge in microservice migration:**  
Itâ€™s not about Docker, Kubernetes, or AWS.  
Itâ€™s about **judgment â€” the art of drawing the right lines** between what belongs together and what should live apart.
